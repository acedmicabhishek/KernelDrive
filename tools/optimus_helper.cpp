// Reference : envyControl

 
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <filesystem>
#include <cstdlib>
#include <cstdio>
#include <array>
#include <memory>
#include <regex>
#include <algorithm>
#include <thread>
#include <chrono>

namespace fs = std::filesystem;

const std::string BLACKLIST_PATH = "/etc/modprobe.d/blacklist-nvidia.conf";
const std::string UDEV_INTEGRATED_PATH = "/etc/udev/rules.d/50-remove-nvidia.rules";
const std::string UDEV_PM_PATH = "/etc/udev/rules.d/80-nvidia-pm.rules";
const std::string XORG_PATH = "/etc/X11/xorg.conf";
const std::string EXTRA_XORG_PATH = "/etc/X11/xorg.conf.d/10-nvidia.conf";
const std::string MODESET_PATH = "/etc/modprobe.d/nvidia.conf";
const std::string SDDM_XSETUP_PATH = "/usr/share/sddm/scripts/Xsetup";
const std::string LIGHTDM_SCRIPT_PATH = "/etc/lightdm/nvidia.sh";
const std::string LIGHTDM_CONFIG_PATH = "/etc/lightdm/lightdm.conf.d/20-nvidia.conf";

const std::string BLACKLIST_CONTENT = R"(# Automatically generated by KernelDrive (Optimus)
blacklist nouveau
blacklist nova_core
blacklist nova_drm
blacklist nvidia
blacklist nvidia_drm
blacklist nvidia_uvm
blacklist nvidia_modeset
blacklist nvidia_current
blacklist nvidia_current_drm
blacklist nvidia_current_uvm
blacklist nvidia_current_modeset
blacklist i2c_nvidia_gpu
alias nouveau off
alias nova_core off
alias nova_drm off
alias nvidia off
alias nvidia_drm off
alias nvidia_uvm off
alias nvidia_modeset off
alias nvidia_current off
alias nvidia_current_drm off
alias nvidia_current_uvm off
alias nvidia_current_modeset off
alias i2c_nvidia_gpu off
)";

const std::string UDEV_INTEGRATED = R"(# Automatically generated by KernelDrive (Optimus)
# Remove NVIDIA USB xHCI Host Controller devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c0330", ATTR{power/control}="auto", ATTR{remove}="1"
# Remove NVIDIA USB Type-C UCSI devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c8000", ATTR{power/control}="auto", ATTR{remove}="1"
# Remove NVIDIA Audio devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x040300", ATTR{power/control}="auto", ATTR{remove}="1"
# Remove NVIDIA VGA/3D controller devices
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x03[0-9]*", ATTR{power/control}="auto", ATTR{remove}="1"
)";

const std::string UDEV_PM_CONTENT = R"(# Automatically generated by KernelDrive (Optimus)
# Remove NVIDIA USB xHCI Host Controller devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c0330", ATTR{remove}="1"
# Remove NVIDIA USB Type-C UCSI devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x0c8000", ATTR{remove}="1"
# Remove NVIDIA Audio devices, if present
ACTION=="add", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x040300", ATTR{remove}="1"
# Enable runtime PM for NVIDIA VGA/3D controller devices on driver bind
ACTION=="bind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030000", TEST=="power/control", ATTR{power/control}="auto"
ACTION=="bind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030200", TEST=="power/control", ATTR{power/control}="auto"
# Disable runtime PM for NVIDIA VGA/3D controller devices on driver unbind
ACTION=="unbind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030000", TEST=="power/control", ATTR{power/control}="on"
ACTION=="unbind", SUBSYSTEM=="pci", ATTR{vendor}=="0x10de", ATTR{class}=="0x030200", TEST=="power/control", ATTR{power/control}="on"
)";

const std::string MODESET_CONTENT = R"(# Automatically generated by KernelDrive (Optimus)
options nvidia-drm modeset=1
options nvidia NVreg_UsePageAttributeTable=1 NVreg_InitializeSystemMemoryAllocations=0
)";

std::string exec(const char* cmd) {
    std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    if (!pipe) return "";
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}

void create_file(const std::string& path, const std::string& content) {
    fs::create_directories(fs::path(path).parent_path());
    std::ofstream out(path);
    out << content;
    out.close();
    std::cout << "Created: " << path << std::endl;
}

void remove_file(const std::string& path) {
    if (fs::exists(path)) {
        fs::remove(path);
        std::cout << "Removed: " << path << std::endl;
    }
}

std::string get_nvidia_bus_id() {
    std::string out = exec("lspci -n");
    // Look for 10de (Nvidia) and class 0300 (VGA) or 0302 (3D)
    // lspci -n format: 01:00.0 0300: 10de:25a0 (rev a1)
    std::istringstream iss(out);
    std::string line;
    while (std::getline(iss, line)) {
        if (line.find("10de:") != std::string::npos && 
           (line.find(" 0300:") != std::string::npos || line.find(" 0302:") != std::string::npos)) {
            std::string id = line.substr(0, line.find(' '));
            unsigned int bus, dev, func;
            sscanf(id.c_str(), "%x:%x.%x", &bus, &dev, &func);
            char buf[64];
            snprintf(buf, sizeof(buf), "PCI:%u:%u:%u", bus, dev, func);
            return std::string(buf);
        }
    }
    return "";
}

std::string get_igpu_vendor() {
    std::string out = exec("lspci -v");
    if (out.find("Intel Corporation") != std::string::npos && 
       (out.find("VGA compatible controller") != std::string::npos || out.find("Display controller") != std::string::npos)) {
        return "intel";
    }
    if (out.find("Advanced Micro Devices") != std::string::npos || out.find("ATI") != std::string::npos) {
        return "amd";
    }
    return "intel";
}

void cleanup_files() {
    remove_file(BLACKLIST_PATH);
    remove_file(UDEV_INTEGRATED_PATH);
    remove_file(UDEV_PM_PATH);
    remove_file(XORG_PATH);
    remove_file(EXTRA_XORG_PATH);
    remove_file(MODESET_PATH);
    remove_file("/etc/X11/xorg.conf.d/90-nvidia.conf");
    remove_file("/lib/udev/rules.d/50-remove-nvidia.rules");
    remove_file("/lib/udev/rules.d/80-nvidia-pm.rules");
}

void rebuild_initramfs() {
    std::cout << "Rebuilding initramfs..." << std::endl;
    if (fs::exists("/etc/arch-release")) {
        system("mkinitcpio -P");
    } else if (fs::exists("/etc/debian_version")) {
        system("update-initramfs -u -k all");
    } else if (fs::exists("/usr/bin/dracut")) {
        system("dracut --force --regenerate-all");
    } else {
        std::cerr << "Warning: Could not detect method to rebuild initramfs." << std::endl;
    }
}

std::string get_xorg_intel(const std::string& bus_id) {
    return R"(Section "ServerLayout"
    Identifier "layout"
    Screen 0 "nvidia"
    Inactive "intel"
EndSection

Section "Device"
    Identifier "nvidia"
    Driver "nvidia"
    BusID ")" + bus_id + R"("
EndSection

Section "Screen"
    Identifier "nvidia"
    Device "nvidia"
    Option "AllowEmptyInitialConfiguration"
EndSection

Section "Device"
    Identifier "intel"
    Driver "modesetting"
EndSection

Section "Screen"
    Identifier "intel"
    Device "intel"
EndSection
)";
}

std::string get_xorg_amd(const std::string& bus_id) {
    return R"(Section "ServerLayout"
    Identifier "layout"
    Screen 0 "nvidia"
    Inactive "amdgpu"
EndSection

Section "Device"
    Identifier "nvidia"
    Driver "nvidia"
    BusID ")" + bus_id + R"("
EndSection

Section "Screen"
    Identifier "nvidia"
    Device "nvidia"
    Option "AllowEmptyInitialConfiguration"
EndSection

Section "Device"
    Identifier "amdgpu"
    Driver "amdgpu"
EndSection

Section "Screen"
    Identifier "amd"
    Device "amdgpu"
EndSection
)";
}

void switch_mode(const std::string& mode) {
    std::cout << "Switching to mode: " << mode << std::endl;
    cleanup_files();

    if (mode == "integrated") {
        system("systemctl disable nvidia-persistenced.service >/dev/null 2>&1");
        create_file(BLACKLIST_PATH, BLACKLIST_CONTENT);
        create_file(UDEV_INTEGRATED_PATH, UDEV_INTEGRATED);
        rebuild_initramfs();
    } 
    else if (mode == "hybrid") {
        system("systemctl enable nvidia-persistenced.service >/dev/null 2>&1");
        create_file(MODESET_PATH, MODESET_CONTENT);
        create_file(UDEV_PM_PATH, UDEV_PM_CONTENT);
        rebuild_initramfs();
    }
    else if (mode == "nvidia") {
        system("systemctl enable nvidia-persistenced.service >/dev/null 2>&1");
        
        std::string bus_id = get_nvidia_bus_id();
        if (bus_id.empty()) {
            std::cerr << "Error: Could not find Nvidia GPU Bus ID. Are you in Integrated mode?" << std::endl;
            exit(1);
        }
        
        std::string igpu = get_igpu_vendor();
        if (igpu == "intel") {
            create_file(XORG_PATH, get_xorg_intel(bus_id));
        } else {
            create_file(XORG_PATH, get_xorg_amd(bus_id));
        }

        create_file(MODESET_PATH, MODESET_CONTENT);
        rebuild_initramfs();
    }
    else {
        std::cerr << "Unknown mode: " << mode << std::endl;
        exit(1);
    }
    std::cout << "Done. Please reboot." << std::endl;
}

std::string query_mode() {
    if (fs::exists(BLACKLIST_PATH) && fs::exists(UDEV_INTEGRATED_PATH)) {
        return "integrated";
    }
    if (fs::exists(XORG_PATH) && fs::exists(MODESET_PATH)) {
        return "nvidia";
    }
    return "hybrid";
}

int main(int argc, char** argv) {
    if (geteuid() != 0 && argc > 1 && std::string(argv[1]) != "--query") {
        std::cerr << "Root privileges required." << std::endl;
        return 1;
    }

    std::string cmd = (argc > 1) ? argv[1] : "--help";

    if (cmd == "--query") {
        std::cout << query_mode() << std::endl;
    } 
    else if (cmd == "--integrated") {
        switch_mode("integrated");
    }
    else if (cmd == "--hybrid") {
        switch_mode("hybrid");
    }
    else if (cmd == "--nvidia") {
        switch_mode("nvidia");
    }
    else {
        std::cout << "Usage: optimus_helper [--query|--integrated|--hybrid|--nvidia]" << std::endl;
    }

    return 0;
}
